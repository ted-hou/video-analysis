expName = 'daisy10_20211020';
animalName = strsplit(expName, '_'); date = str2double(animalName{2}); animalName = animalName{1};
smoothingWindow_jointVel = 10;
smoothingWindow_spikeCount = 10;


%% Read tetrode recording (SLOW!!!)
fname_tr = sprintf('C:\\SERVER\\%s\\SpikeSort\\tr_sorted_%s.mat', animalName, expName);
t_read = tic();
fprintf(1, 'Slowly reading TetrodeRecording object from file: %s...', fname_tr);
load(fname_tr)
fprintf('\nDone (%s).\n', seconds(toc(t_read)))
clear t_read

% Read video tracking data, csv to table
files_vtd = sortrows(struct2table(dir(sprintf('C:\\SERVER\\daisy10\\%s\\%s_*.csv', expName, expName))), 'datenum', 'descend'); % Use the newest csv file generated by DeepLabCut
fname_vtd = sprintf('%s\\%s', files_vtd.folder{1}, files_vtd.name{1});
opts = detectImportOptions(fname_vtd, 'NumHeaderLines', 3);
opts.VariableNamesLine = 2;

t_read = tic();
fprintf(1, 'Reading video tracking data from file %s...', fname_vtd);
vtd = readtable(fname_vtd, opts);
fprintf(1, '\nDone (%s).\n', seconds(toc(t_read)));

% Set colnames
vtd.Properties.VariableNames{1} = 'FrameNumber';
w = length(vtd.Properties.VariableNames);
for i = 2:w
    splitName = strsplit(vtd.Properties.VariableNames{i}, '_');
    if length(splitName) == 1
        vtd.Properties.VariableNames{i} = [splitName{1}, '_X'];
        pos = table2array(smoothdata(vtd(:, i:i+1), 'gaussian', smoothingWindow_jointVel));
        vel = [0, 0; diff(pos, 1)];
        spd = sqrt(sum(vel.^2, 2));
        vtd = addvars(vtd, vel(:, 1), vel(:, 2), spd, 'NewVariableNames', {[splitName{1}, '_VelX'], [splitName{1}, '_VelY'], [splitName{1}, '_Speed']});
    elseif splitName{2} == '1'
        vtd.Properties.VariableNames{i} = [splitName{1}, '_Y'];
    elseif splitName{2} == '2'
        vtd.Properties.VariableNames{i} = [splitName{1}, '_Likelihood'];
    end
end
clear files_vtd i opts splitName w pos vel spd t_read


%% Get time offset between video frame 0 and recording start time
fname_ac = sprintf('C:\\SERVER\\%s\\%s\\%s.mat', animalName, expName, expName);
load(fname_ac), ac = obj; clear obj

% CameraConnection uses DATENUM to store local time (Boston) rather than UTC, so we need to specify timezone when converting back to DATETIME.
sparseTimestamps = datetime([ac.Cameras.Camera.EventLog.Timestamp], 'ConvertFrom', 'datenum', 'TimeZone', 'America/New_York', 'Format', 'yyyy-MM-dd HH:mm:SSS');
sparseFrameNumbers = [ac.Cameras.Camera.EventLog.FrameNumber];

% Interpolate frame timestamps b/c CameraConnection only stores timestamps
% for every 10th frame
vtd.FrameTimestamp = interp1(sparseFrameNumbers, sparseTimestamps, vtd.FrameNumber, 'linear');

% Store timestamps as seconds after Ephys start
vtd.EphysTimestamp = seconds(vtd.FrameTimestamp - tr.StartTime);

% Truncate negative timestamps
vtd = vtd(vtd.EphysTimestamp > 0, :);

clear sparseFrameNumbers sparseTimestamps

%% Process unit list
fname_peth = 'C:\SERVER\PETH_TripleCross_4shank.mat'; % 'PETH_daisy10_20211020.mat';
S = load(fname_peth);
units = cell2table(S.batchPlotListStim, 'VariableNames', {'AnimalName', 'Date', 'Electrode', 'Channel', 'Unit'});
units = units(units.Date == date & strcmpi(units.AnimalName, animalName), :); % Get all ephys units from this session.
clear S

% Calculate spike counts across whole session
units.SpikeCounts = zeros(height(units), height(vtd));
for iUnit = 1:height(units)
    sc = countSpikes(tr, units.Channel(iUnit), units.Unit(iUnit), [0; vtd.EphysTimestamp]);
    units.SpikeCounts(iUnit, :) = sc;
    vtd = addvars(vtd, sc', smoothdata(sc', 'gaussian', smoothingWindow_spikeCount), 'NewVariableNames', {sprintf('SpikeCount_E%iU%i', units.Electrode(iUnit), units.Unit(iUnit)), sprintf('SmoothSpikeCount_E%iU%i', units.Electrode(iUnit), units.Unit(iUnit))});
end
clear iUnit sc

%% Get events
clear ti events trialProgress

events.TrialStart = getEventTimes(tr, ac, 'TRIAL_START');
events.CueOn = getEventTimes(tr, ac, 'CUE_ON');
events.LeverPressed = getEventTimes(tr, ac, 'LEVER_PRESSED');
events.LickOn = getEventTimes(tr, ac, 'LICK');

ti.press = getTrialInfo(vtd, events.TrialStart, events.LeverPressed, events.LickOn, -3, 1);
ti.lick = getTrialInfo(vtd, events.TrialStart, events.LickOn, events.LeverPressed, -3, 1);

% Logicals - in trial window
vtd.InTrial_Press = ti.press.inTrial;
vtd.InTrial_Lick = ti.lick.inTrial;
assert(sum(vtd.InTrial_Press & vtd.InTrial_Lick) == 0) % Make sure lick/press trials don't overlap
vtd.InTrial = ti.press.inTrial | ti.lick.inTrial;
vtd.InPreTrial_Press = ti.press.inPreTrial;
vtd.InPreTrial_Lick = ti.lick.inPreTrial;
vtd.InPostTrial_Press = ti.press.inPostTrial;
vtd.InPostTrial_Lick = ti.lick.inPostTrial;
vtd.InPreTrial = vtd.InPreTrial_Press | vtd.InPreTrial_Lick;
vtd.InPostTrial = vtd.InPostTrial_Press | vtd.InPostTrial_Lick;
vtd.InWindow = vtd.InTrial | vtd.InPreTrial | vtd.InPostTrial;

% Trial Progression (fraction, 0 - 1)
vtd.TrialProgress_Press = zeros(height(vtd), 1); 
vtd.TrialProgress_Lick = zeros(height(vtd), 1);
vtd.TrialProgress_Press(vtd.InTrial_Press) = ti.press.sigy;
vtd.TrialProgress_Lick(vtd.InTrial_Lick) = ti.lick.sigy;
vtd.TrialProgress = vtd.TrialProgress_Press + vtd.TrialProgress_Lick;

vtd.TrialProgress_PreTrial_Press = zeros(height(vtd), 1);
vtd.TrialProgress_PostTrial_Press = zeros(height(vtd), 1);
vtd.TrialProgress_PreTrial_Lick = zeros(height(vtd), 1);
vtd.TrialProgress_PostTrial_Lick = zeros(height(vtd), 1);
vtd.TrialProgress_PreTrial_Press(vtd.InPreTrial_Press) = ti.press.sigypre;
vtd.TrialProgress_PreTrial_Lick(vtd.InPreTrial_Lick) = ti.lick.sigypre;
vtd.TrialProgress_PostTrial_Press(vtd.InPostTrial_Press) = ti.press.sigypost;
vtd.TrialProgress_PostTrial_Lick(vtd.InPostTrial_Lick) = ti.lick.sigypost;
vtd.TrialProgress_PreTrial = vtd.TrialProgress_PreTrial_Press + vtd.TrialProgress_PreTrial_Lick;
vtd.TrialProgress_PostTrial = vtd.TrialProgress_PostTrial_Press + vtd.TrialProgress_PostTrial_Lick;

% Trial Length
vtd.TrialLength_Press = zeros(height(vtd), 1);
vtd.TrialLength_Lick = zeros(height(vtd), 1);
vtd.TrialLength_PreTrial_Press = zeros(height(vtd), 1);
vtd.TrialLength_PreTrial_Lick = zeros(height(vtd), 1);
vtd.TrialLength_PostTrial_Press = zeros(height(vtd), 1);
vtd.TrialLength_PostTrial_Lick = zeros(height(vtd), 1);

vtd.TrialLength_Press(vtd.InTrial_Press) = ti.press.sigylen;
vtd.TrialLength_Lick(vtd.InTrial_Lick) = ti.lick.sigylen;
vtd.TrialLength_PreTrial_Press(vtd.InPreTrial_Press) = ti.press.sigyprelen;
vtd.TrialLength_PreTrial_Lick(vtd.InPreTrial_Lick) = ti.lick.sigyprelen;
vtd.TrialLength_PostTrial_Press(vtd.InPostTrial_Press) = ti.press.sigypostlen;
vtd.TrialLength_PostTrial_Lick(vtd.InPostTrial_Lick) = ti.lick.sigypostlen;
vtd.TrialLength = vtd.TrialLength_Press + vtd.TrialLength_Lick;
vtd.TrialLength_PreTrial = vtd.TrialLength_PreTrial_Press + vtd.TrialLength_PreTrial_Lick;
vtd.TrialLength_PostTrial = vtd.TrialLength_PostTrial_Press + vtd.TrialLength_PostTrial_Lick;


clear ev evname bins oddBins

%% GLM
modelspec = cell(height(units), 1);
models = cell(height(units), 1);
for i = 1:height(units)
    e = units.Electrode(i);
    u = units.Unit(i);
    modelspec{i} = sprintf('SmoothSpikeCount_E%iU%i ~ TrialProgress*TrialLength + TrialProgress_PreTrial*TrialLength_PreTrial + TrialProgress_PostTrial*TrialLength_PostTrial + Jaw_VelX*Jaw_VelY + Nose_VelX*Nose_VelY + Spine_VelX*Spine_VelY + Tail_VelX*Tail_VelY + ShoulderR_VelX*ShoulderR_VelY + ElbowR_VelX*ElbowR_VelY + HandR_VelX*HandR_VelY + HipR_VelX*HipR_VelY + AnkleR_VelX*AnkleR_VelY + FootR_VelX*FootR_VelY + HandL_VelX*HandL_VelY', e, u);
    mdl = fitglm(vtd(vtd.InWindow, :), modelspec{i}, 'Distribution', 'poisson');
    models{i} = mdl;
%     
%     figure(i)
%     y = table2array(vtd(:, sprintf('SmoothSpikeCount_E%iU%i', e, u)));
%     subplot(1, 3, 1)
%     plot(vtd.HandR_Speed, y, '.')
%     xlabel('HandR Speed')
%     ylabel(sprintf('SmoothSpikeCount_E%iU%i', e, u))
%     subplot(1, 3, 2)
%     plot(vtd.HandR_VelX, y, '.')
%     xlabel('HandR Vel X')
%     subplot(1, 3, 3)
%     plot(vtd.HandR_VelY, y, '.')
%     xlabel('HandR Vel Y')
end

clear i e u mdl


%% Plot unit PETHs and significant predictors
dirName = sprintf('C:\\SERVER\\%s\\VideoAnalysis\\GLM_%s', animalName, datestr(datetime, 'yyyymmdd_HHMMSS'));
mkdir(dirName)
fid = fopen(sprintf('%s\\modelspec.txt', dirName), 'wt');
fprintf(fid, modelspec{1});
fclose(fid);
for i = 1:height(units)
    [hFigure, ~, ~, hTitle] = tr.PlotUnitSimple_TwoEvents(units.Channel(i), units.Unit(i), 'LeaveSpaceForAnnotation', true, 'PlotType', 'PETH');
    hFigure.Position = [0, 0, 0.75, 1];
    
    coeff = models{i}.Coefficients;
    coeff = coeff(coeff.pValue < 0.05, :);
    coeff = sortrows(coeff, 'pValue');
    
    coeff_str = evalc('disp(coeff)');
    coeff_str = strrep(coeff_str, '<strong>', '\bf');
    coeff_str = strrep(coeff_str, '</strong>', '\rm');
    coeff_str = strrep(coeff_str, '_', '\_');

    dev = devianceTest(models{i});
    try
        dev_str = sprintf('\\bfChi^2-statistic vs. constant model: %.2f, p-value = %.2f\\rm\n\n', dev.chi2Stat(2), dev.pValue(2));
    catch
        dev_str = sprintf('\\bfF-statistic vs. constant model: %.2f, p-value = %.2f\\rm\n\n', dev.FStat(2), dev.pValue(2));
    end

    annotation(hFigure, 'Textbox', 'String', [dev_str, coeff_str], 'Interpreter', 'Tex', 'FontName', get(0,'FixedWidthFontName'), 'Units', 'Normalized', 'Position',[0 0 0.66 0.33], 'HorizontalAlignment', 'center', 'LineStyle', 'none');
    ax = axes(hFigure, 'OuterPosition', [0.66, 0.1, 0.33, 0.23]);
    hold(ax, 'on')
    t = (0:height(models{i}.Fitted)-1) * 1/30;
    plot(ax, t, table2array(models{i}.Variables(:, models{i}.Formula.ResponseName)) * 30, 'DisplayName', 'Data')
    plot(ax, t, table2array(models{i}.Fitted(:, 'Response')) * 30, 'DisplayName', 'Fitted')
    xlim(ax, [0, 60])
    hold(ax, 'off')
    xlabel(ax, 'Time (s)')
    ylabel(ax, 'Spike Rate (sp/s)')
    legend(ax)
    title(ax, sprintf('R^2 = %f', models{i}.Rsquared.Ordinary))

    print(hFigure, sprintf('%s\\%s', dirName, hTitle.String), '-dpng')
end

clear i coeff coeff_str dev dev_str t hFigure hTitle ax

%% Functions
function sc = countSpikes(tr, channel, unit, edges)
    spiketimes = tr.Spikes(channel).Timestamps(tr.Spikes(channel).Cluster.Classes == unit);
    sc = histcounts(spiketimes, edges);
end

function t = getEventTimes(tr, ac, eventName)
    t = seconds(datetime(ac.EventMarkers(ac.EventMarkers(:, 1) == find(strcmpi(ac.EventMarkerNames, eventName), 1), 3), 'ConvertFrom', 'datenum', 'TimeZone', 'America/New_York') - tr.StartTime);
    t = reshape(t, 1, []);
end

function ti = getTrialInfo(vtd, reference, event, eventExclude, preWindow, postWindow)
    if nargin < 5
        preWindow = -1;
    end
    if nargin < 6
        postWindow = 1;
    end

    [ti.ref, ti.event, ~, ~, ~] = TetrodeRecording.FindFirstInTrial(reference, event, eventExclude);
    ti.sigx = reshape([zeros(1, length(ti.ref)); ones(1, length(ti.event))], 1, []);
    ti.sigxlen = reshape(repmat(ti.event - ti.ref, 2, 1), 1, []);
    ti.tx = reshape([ti.ref; ti.event], 1, []);
    ti.txpre = reshape([ti.ref + preWindow; ti.ref], 1, []);
    ti.txpost = reshape([ti.event; ti.event + postWindow;], 1, []);
    
    % Use timeseries objects for resampling data
    tsx = timeseries(ti.sigx, ti.tx);
    tsxpre = timeseries(ti.sigx, ti.txpre);
    tsxpost = timeseries(ti.sigx, ti.txpost);
    tsxlen = timeseries(ti.sigxlen, ti.tx);
    tsxprelen = timeseries(ti.sigxlen, ti.txpre);
    tsxpostlen = timeseries(ti.sigxlen, ti.txpost);
    
    [ti.ty, ti.inTrial] = getInTrial(ti.tx, vtd.EphysTimestamp);
    [ti.typre, ti.inPreTrial] = getInTrial(ti.txpre, vtd.EphysTimestamp);
    [ti.typost, ti.inPostTrial] = getInTrial(ti.txpost, vtd.EphysTimestamp);
    
    tsy = resample(tsx, ti.ty, 'linear');
    tsypre = resample(tsxpre, ti.typre, 'linear');
    tsypost = resample(tsxpost, ti.typost, 'linear');
    tsylen = resample(tsxlen, ti.ty, 'linear');
    tsyprelen = resample(tsxprelen, ti.typre, 'linear');
    tsypostlen = resample(tsxpostlen, ti.typost, 'linear');
    
    ti.sigy = squeeze(tsy.Data);
    ti.sigypre = squeeze(tsypre.Data);
    ti.sigypost = squeeze(tsypost.Data);
    ti.sigylen = squeeze(tsylen.Data);
    ti.sigyprelen = squeeze(tsyprelen.Data);
    ti.sigypostlen = squeeze(tsypostlen.Data);
end

function [ty, inTrial] = getInTrial(tx, ty)
    [~, ~, bins] = histcounts(ty, tx);
    inTrial = rem(bins, 2) ~= 0; % Keep odd bins these occur during trial.
    ty = ty(inTrial);
end