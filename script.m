expName = 'daisy10_20211020';
animalName = strsplit(expName, '_'); date = str2double(animalName{2}); animalName = animalName{1};
smoothingWindow_jointVel = 10;
smoothingWindow_spikeCount = 10;


%% Read tetrode recording (SLOW!!!)
fname_tr = sprintf('C:\\SERVER\\%s\\SpikeSort\\tr_sorted_%s.mat', animalName, expName);
t_read = tic();
fprintf(1, 'Slowly reading TetrodeRecording object from file: %s...', fname_tr);
load(fname_tr)
fprintf('\nDone (%s).\n', seconds(toc(t_read)))
clear t_read

%% Read video tracking data, csv to table
files_vtd = sortrows(struct2table(dir(sprintf('C:\\SERVER\\daisy10\\%s\\%s_*.csv', expName, expName))), 'datenum', 'descend'); % Use the newest csv file generated by DeepLabCut
fname_vtd = sprintf('%s\\%s', files_vtd.folder{1}, files_vtd.name{1});
opts = detectImportOptions(fname_vtd, 'NumHeaderLines', 3);
opts.VariableNamesLine = 2;

t_read = tic();
fprintf(1, 'Reading video tracking data from file %s...', fname_vtd);
vtd = readtable(fname_vtd, opts);
fprintf(1, '\nDone (%s).\n', seconds(toc(t_read)));

% Set colnames
vtd.Properties.VariableNames{1} = 'FrameNumber';
w = length(vtd.Properties.VariableNames);
for i = 2:w
    splitName = strsplit(vtd.Properties.VariableNames{i}, '_');
    if length(splitName) == 1
        vtd.Properties.VariableNames{i} = [splitName{1}, '_X'];
        pos = table2array(smoothdata(vtd(:, i:i+1), 'gaussian', smoothingWindow_jointVel));
        vel = [0, 0; diff(pos, 1)];
        spd = sqrt(sum(vel.^2, 2));
        vtd = addvars(vtd, vel(:, 1), vel(:, 2), spd, 'NewVariableNames', {[splitName{1}, '_VelX'], [splitName{1}, '_VelY'], [splitName{1}, '_Speed']});
    elseif splitName{2} == '1'
        vtd.Properties.VariableNames{i} = [splitName{1}, '_Y'];
    elseif splitName{2} == '2'
        vtd.Properties.VariableNames{i} = [splitName{1}, '_Likelihood'];
    end
end
clear files_vtd i opts splitName w pos vel spd t_read


%% Get time offset between video frame 0 and recording start time
fname_ac = sprintf('C:\\SERVER\\%s\\%s\\%s.mat', animalName, expName, expName);
load(fname_ac), ac = obj; clear obj

% CameraConnection uses DATENUM to store local time (Boston) rather than UTC, so we need to specify timezone when converting back to DATETIME.
sparseTimestamps = datetime([ac.Cameras.Camera.EventLog.Timestamp], 'ConvertFrom', 'datenum', 'TimeZone', 'America/New_York', 'Format', 'yyyy-MM-dd HH:mm:SSS');
sparseFrameNumbers = [ac.Cameras.Camera.EventLog.FrameNumber];

% Interpolate frame timestamps b/c CameraConnection only stores timestamps
% for every 10th frame
vtd.FrameTimestamp = interp1(sparseFrameNumbers, sparseTimestamps, vtd.FrameNumber, 'linear');

% Store timestamps as seconds after Ephys start
vtd.EphysTimestamp = seconds(vtd.FrameTimestamp - tr.StartTime);

% Truncate negative timestamps
vtd = vtd(vtd.EphysTimestamp > 0, :);

clear sparseFrameNumbers sparseTimestamps

%% Process unit list
fname_peth = 'C:\SERVER\PETH_TripleCross_4shank.mat'; % 'PETH_daisy10_20211020.mat';
S = load(fname_peth);
units = cell2table(S.batchPlotListStim, 'VariableNames', {'AnimalName', 'Date', 'Electrode', 'Channel', 'Unit'});
units = units(units.Date == date & strcmpi(units.AnimalName, animalName), :); % Get all ephys units from this session.
clear S

%% Calculate spike counts across whole session
units.SpikeCounts = zeros(height(units), height(vtd));
for iUnit = 1:height(units)
    sc = countSpikes(tr, units.Channel(iUnit), units.Unit(iUnit), [0; vtd.EphysTimestamp]);
    units.SpikeCounts(iUnit, :) = sc;
    vtd = addvars(vtd, sc', smoothdata(sc', 'gaussian', smoothingWindow_spikeCount), 'NewVariableNames', {sprintf('SpikeCount_E%iU%i', units.Electrode(iUnit), units.Unit(iUnit)), sprintf('SmoothSpikeCount_E%iU%i', units.Electrode(iUnit), units.Unit(iUnit))});
end
clear iUnit sc

%% Get events
clear events trialProgress

events.TrialStart = getEventTimes(tr, ac, 'TRIAL_START');
events.CueOn = getEventTimes(tr, ac, 'CUE_ON');
events.LeverPressed = getEventTimes(tr, ac, 'LEVER_PRESSED');
events.LickOn = getEventTimes(tr, ac, 'LICK');

trialProgress.Press = getTrialProgressSignal(vtd, events.CueOn, events.LeverPressed, events.LickOn, -1, 1);
trialProgress.Lick = getTrialProgressSignal(vtd, events.CueOn, events.LickOn, events.LeverPressed, -1, 1);

vtd.InTrial_Press = trialProgress.Press.inTrial;
vtd.InTrial_Lick = trialProgress.Lick.inTrial;
vtd.InTrial = trialProgress.Press.inTrial | trialProgress.Lick.inTrial;

vtd.TrialProgress_Press = zeros(height(vtd), 1); 
vtd.TrialProgress_Lick = zeros(height(vtd), 1);
vtd.TrialProgress = zeros(height(vtd), 1);

vtd.TrialProgress_Press(trialProgress.Press.inTrial) = trialProgress.Press.sigy;
vtd.TrialProgress_Lick(trialProgress.Lick.inTrial) = trialProgress.Lick.sigy;
vtd.TrialProgress(trialProgress.Press.inTrial) = trialProgress.Press.sigy;
vtd.TrialProgress(trialProgress.Lick.inTrial) = trialProgress.Lick.sigy;


vtd.Progress_PreTrial_Press = zeros(height(vtd), 1);
vtd.Progress_PostTrial_Press = zeros(height(vtd), 1);
vtd.Progress_PreTrial_Lick = zeros(height(vtd), 1);
vtd.Progress_PostTrial_Lick = zeros(height(vtd), 1);
vtd.PreTrial_Press = trialProgress.Press.preTrial;
vtd.PreTrial_Lick = trialProgress.Lick.preTrial;
vtd.PostTrial_Press = trialProgress.Press.postTrial;
vtd.PostTrial_Lick = trialProgress.Lick.postTrial;
vtd.PreTrial = vtd.PreTrial_Press | vtd.PreTrial_Lick;
vtd.PostTrial = vtd.PostTrial_Press | vtd.PostTrial_Lick;
vtd.InWindow = vtd.InTrial | vtd.PreTrial | vtd.PostTrial;

vtd.Progress_PreTrial_Press(vtd.PreTrial_Press) = trialProgress.Press.sigypre;
vtd.Progress_PreTrial_Lick(vtd.PreTrial_Lick) = trialProgress.Lick.sigypre;
vtd.Progress_PostTrial_Press(vtd.PostTrial_Press) = trialProgress.Press.sigypost;
vtd.Progress_PostTrial_Lick(vtd.PostTrial_Lick) = trialProgress.Lick.sigypost;


clear ev evname bins oddBins

%% GLM
modelspec = cell(height(units), 1);
models = cell(height(units), 1);
for i = 1:height(units)
    e = units.Electrode(i);
    u = units.Unit(i);
    modelspec{i} = sprintf('SmoothSpikeCount_E%iU%i ~ TrialProgress_Lick + TrialProgress_Press + Progress_PreTrial_Press + Progress_PreTrial_Lick + Progress_PostTrial_Press + Progress_PostTrial_Lick + Jaw_VelX*Jaw_VelY + Nose_VelX*Nose_VelY + Spine_VelX*Spine_VelY + Tail_VelX*Tail_VelY + ShoulderR_VelX*ShoulderR_VelY + ElbowR_VelX*ElbowR_VelY + HandR_VelX*HandR_VelY + HipR_VelX*HipR_VelY + AnkleR_VelX*AnkleR_VelY + FootR_VelX*FootR_VelY + HandL_VelX*HandL_VelY', e, u);
%     modelspec{i} = sprintf('SmoothSpikeCount_E%iU%i ~ TrialProgress + Jaw_VelX*Jaw_VelY + Nose_VelX*Nose_VelY + Spine_VelX*Spine_VelY + Tail_VelX*Tail_VelY + ShoulderR_VelX*ShoulderR_VelY + ElbowR_VelX*ElbowR_VelY + HandR_VelX*HandR_VelY + HipR_VelX*HipR_VelY + AnkleR_VelX*AnkleR_VelY + FootR_VelX*FootR_VelY + HandL_VelX*HandL_VelY', e, u);
    mdl = fitglm(vtd(vtd.InWindow, :), modelspec{i}, 'Distribution', 'poisson');
    models{i} = mdl;
%     
%     figure(i)
%     y = table2array(vtd(:, sprintf('SmoothSpikeCount_E%iU%i', e, u)));
%     subplot(1, 3, 1)
%     plot(vtd.HandR_Speed, y, '.')
%     xlabel('HandR Speed')
%     ylabel(sprintf('SmoothSpikeCount_E%iU%i', e, u))
%     subplot(1, 3, 2)
%     plot(vtd.HandR_VelX, y, '.')
%     xlabel('HandR Vel X')
%     subplot(1, 3, 3)
%     plot(vtd.HandR_VelY, y, '.')
%     xlabel('HandR Vel Y')
end

clear i e u mdl


%% Plot unit PETHs and significant predictors
dirName = sprintf('C:\\SERVER\\%s\\VideoAnalysis\\GLM_%s', animalName, datestr(datetime, 'yyyymmdd_HHMMSS'));
mkdir(dirName)
for i = 1:height(units)
    [hFigure, ~, ~, hTitle] = tr.PlotUnitSimple_TwoEvents(units.Channel(i), units.Unit(i), 'LeaveSpaceForAnnotation', true, 'PlotType', 'PETH');
    hFigure.Position = [0, 0, 0.75, 1];
    
    coeff = models{i}.Coefficients;
    coeff = coeff(coeff.pValue < 0.05, :);
    coeff = sortrows(coeff, 'pValue');
    
    coeff_str = evalc('disp(coeff)');
    coeff_str = strrep(coeff_str, '<strong>', '\bf');
    coeff_str = strrep(coeff_str, '</strong>', '\rm');
    coeff_str = strrep(coeff_str, '_', '\_');

    dev = devianceTest(models{i});
    try
        dev_str = sprintf('\\bfChi^2-statistic vs. constant model: %.2f, p-value = %.2f\\rm\n\n', dev.chi2Stat(2), dev.pValue(2));
    catch
        dev_str = sprintf('\\bfF-statistic vs. constant model: %.2f, p-value = %.2f\\rm\n\n', dev.FStat(2), dev.pValue(2));
    end

    annotation(hFigure, 'Textbox', 'String', [dev_str, coeff_str], 'Interpreter', 'Tex', 'FontName', get(0,'FixedWidthFontName'), 'Units', 'Normalized', 'Position',[0 0 0.66 0.33], 'HorizontalAlignment', 'center', 'LineStyle', 'none');
    ax = axes(hFigure, 'OuterPosition', [0.66, 0.1, 0.33, 0.23]);
    hold(ax, 'on')
    t = (0:height(models{i}.Fitted)-1) * 1/30;
    plot(ax, t, table2array(models{i}.Variables(:, models{i}.Formula.ResponseName)) * 30, 'DisplayName', 'Data')
    plot(ax, t, table2array(models{i}.Fitted(:, 'Response')) * 30, 'DisplayName', 'Fitted')
    xlim(ax, [0, 60])
    hold(ax, 'off')
    xlabel(ax, 'Time (s)')
    ylabel(ax, 'Spike Rate (sp/s)')
    legend(ax)
    title(ax, sprintf('R^2 = %f', models{i}.Rsquared.Ordinary))

    print(hFigure, sprintf('%s\\%s', dirName, hTitle.String), '-dpng')
end

clear i coeff coeff_str dev dev_str t hFigure hTitle ax

%% Functions
function sc = countSpikes(tr, channel, unit, edges)
    spiketimes = tr.Spikes(channel).Timestamps(tr.Spikes(channel).Cluster.Classes == unit);
    sc = histcounts(spiketimes, edges);
end

function t = getEventTimes(tr, ac, eventName)
    t = seconds(datetime(ac.EventMarkers(ac.EventMarkers(:, 1) == find(strcmpi(ac.EventMarkerNames, eventName), 1), 3), 'ConvertFrom', 'datenum', 'TimeZone', 'America/New_York') - tr.StartTime);
    t = reshape(t, 1, []);
end

function e = getTrialProgressSignal(vtd, reference, event, eventExclude, preWindow, postWindow)
    if nargin < 5
        preWindow = -1;
    end
    if nargin < 6
        postWindow = 1;
    end

    [e.ref, e.event, ~, ~, ~] = TetrodeRecording.FindFirstInTrial(reference, event, eventExclude);
    e.sigx = reshape([zeros(1, length(e.ref)); ones(1, length(e.event))], 1, []);
    e.tx = reshape([e.ref; e.event], 1, []);
    e.txpre = reshape([e.ref + preWindow; e.ref], 1, []);
    e.txpost = reshape([e.event; e.event + postWindow;], 1, []);
    
    tsx = timeseries(e.sigx, e.tx);
    tsxpre = timeseries(e.sigx, e.txpre);
    tsxpost = timeseries(e.sigx, e.txpost);
    
    [e.ty, e.inTrial] = getInTrial(e.tx, vtd.EphysTimestamp);
    [e.typre, e.preTrial] = getInTrial(e.txpre, vtd.EphysTimestamp);
    [e.typost, e.postTrial] = getInTrial(e.txpost, vtd.EphysTimestamp);
    
    tsy = resample(tsx, e.ty, 'linear');
    tsypre = resample(tsxpre, e.typre, 'linear');
    tsypost = resample(tsxpost, e.typost, 'linear');
    
    e.sigy = squeeze(tsy.Data);
    e.sigypre = squeeze(tsypre.Data);
    e.sigypost = squeeze(tsypost.Data);
end

function [ty, inTrial] = getInTrial(tx, ty)
%     ty = vtd.EphysTimestamp;
    [~, ~, bins] = histcounts(ty, tx);
    inTrial = rem(bins, 2) ~= 0; % Keep odd bins these occur during trial.
    ty = ty(inTrial);
end